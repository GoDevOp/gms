package GMS::Schema::Result::Contact;

# Created by DBIx::Class::Schema::Loader
# DO NOT MODIFY THE FIRST PART OF THIS FILE

use strict;
use warnings;

use base 'DBIx::Class::Core';

__PACKAGE__->load_components("InflateColumn::DateTime", "InflateColumn::Object::Enum");

=head1 NAME

GMS::Schema::Result::Contact

=cut

__PACKAGE__->table("contacts");

=head1 ACCESSORS

=head2 id

  data_type: 'integer'
  is_auto_increment: 1
  is_nullable: 0
  sequence: 'contacts_id_seq'

=head2 account_id

  data_type: 'integer'
  is_foreign_key: 1
  is_nullable: 0

=head2 active_change

  data_type: 'integer'
  default_value: -1
  is_foreign_key: 1
  is_nullable: 0

=cut

__PACKAGE__->add_columns(
  "id",
  {
    data_type         => "integer",
    is_auto_increment => 1,
    is_nullable       => 0,
    sequence          => "contacts_id_seq",
  },
  "account_id",
  { data_type => "integer", is_foreign_key => 1, is_nullable => 0 },
  "active_change",
  {
    data_type      => "integer",
    default_value  => -1,
    is_foreign_key => 1,
    is_nullable    => 0,
  },
);
__PACKAGE__->set_primary_key("id");
__PACKAGE__->add_unique_constraint("unique_contact_active_change", ["active_change"]);
__PACKAGE__->add_unique_constraint("unique_account", ["account_id"]);

=head1 RELATIONS

=head2 contact_changes

Type: has_many

Related object: L<GMS::Schema::Result::ContactChange>

=cut

__PACKAGE__->has_many(
  "contact_changes",
  "GMS::Schema::Result::ContactChange",
  { "foreign.contact_id" => "self.id" },
  {},
);

=head2 active_change

Type: belongs_to

Related object: L<GMS::Schema::Result::ContactChange>

=cut

__PACKAGE__->belongs_to(
  "active_change",
  "GMS::Schema::Result::ContactChange",
  { id => "active_change" },
  {},
);

=head2 account

Type: belongs_to

Related object: L<GMS::Schema::Result::Account>

=cut

__PACKAGE__->belongs_to(
  "account",
  "GMS::Schema::Result::Account",
  { id => "account_id" },
  {},
);

=head2 group_contacts

Type: has_many

Related object: L<GMS::Schema::Result::GroupContact>

=cut

__PACKAGE__->has_many(
  "group_contacts",
  "GMS::Schema::Result::GroupContact",
  { "foreign.contact_id" => "self.id" },
  {},
);


# Created by DBIx::Class::Schema::Loader v0.07002 @ 2010-12-26 23:18:37
# DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:h08eYhCWCoMkvN7VX0nTpw

# Not auto-generated by Schema::Loader...
__PACKAGE__->many_to_many(groups => 'group_contacts', 'group');

=head1 METHODS

=head2 new

Constructor. Automatically creates a ContactChange with the initial state of the
Contact.

=cut

sub new {
    my ($class, $args) = @_;

    my @change_arg_names = (
        'name', 'email', 'address'
    );

    my %change_args;
    @change_args{@change_arg_names} = delete @{$args}{@change_arg_names};
    $change_args{change_type} = 'create';
    $change_args{changed_by} = $args->{account_id};

    $args->{contact_changes} = [ \%change_args ];

    return $class->next::method($args);
}

=head2 insert

Inserts this record into the database, along with its automatically-created
ContactChange.

=cut

sub insert {
    my ($self) = @_;
    my $ret;
    my $next_method = $self->next::can;

    $self->result_source->storage->with_deferred_fk_checks(sub {
            $ret = $self->$next_method();
            $self->active_change($self->contact_changes->single);
            $self->update;
        });

    return $ret;
}

=head2 name

Returns the contact's full name, as retrieved from the active_change.

=cut

sub name {
    my ($self) = @_;
    return $self->active_change->name;
}

=head2 email

Returns the contact's email address, as retrieved from the active_change.

=cut

sub email {
    my ($self) = @_;
    return $self->active_change->email;
}

=head2 address

Returns the contact's address, as retrieved from the active_change.

=cut

sub address {
    my ($self) = @_;
    return $self->active_change->address;
}

=head2 change

    $contact->change($account, $changetype, \%args);

Creates a related ContactChange with the modifications specified in %args.
Unchanged fields are populated from the contact's current state.

$account and $changetype are the account making this change and the type of
change (create, request, approve or admin).

=cut

sub change {
    my ($self, $account, $change_type, $args) = @_;

    my $active_change = $self->active_change;

    my %change_args = (
        changed_by => $account,
        change_type => $change_type,
        name => $args->{name} || $active_change->name,
        address => $args->{address} || $active_change->address,
        email => $args->{email} || $active_change->email
    );

    my $ret = $self->add_to_contact_changes(\%change_args);
    $self->active_change($ret) if $change_type ne 'request';
    $self->update;
    return $ret;
}

=head2 approve_change

    $contact->approve_change($change, $approving_account);

If the given change is a request, then create and return a new change identical
to it except for the type, which will be 'approve', and the user, which must be
provided.  The effect is to approve the given request.

If the given change isn't a request, calling this is an error.

=cut

sub approve_change {
    my ($self, $change, $account) = @_;

    die GMS::Exception::InvalidChange->new("Can't approve a change that isn't a request")
        unless $change->change_type eq 'request';

    die GMS::Exception::InvalidChange->new("Need an account to approve a change") unless $account;

    my $ret = $self->active_change($change->copy({ change_type => 'approve', changed_by => $account}));
    $self->update;
    return $ret;
}


# You can replace this text with custom content, and it will be preserved on regeneration
1;
